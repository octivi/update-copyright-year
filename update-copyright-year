#!/usr/bin/env bash
# SPDX-FileCopyrightText: 2025-2026  IMAGIN sp. z o.o.
# SPDX-FileContributor: Marcin Engelmann <mengelmann@octivi.com>
# SPDX-License-Identifier: MIT
#
# This file is part of the configuration created by Octivi's DevOps team.
# Details at https://octivi.com/devops
#
# This script is part of a GitHub Action available on GitHub Marketplace:
# https://github.com/marketplace/actions/update-copyright-year
#
# Source code repository https://github.com/octivi/update-copyright-year
#
# Update copyright years in source file headers by scanning targets and applying header regexes.

# >>> OBB:BEGIN variant=header
# Octivi Bash Boilerplate (OBB) Header
# Part of Octivi Bash Boilerplate https://github.com/octivi/bash-boilerplate
################################################################################
# Unofficial Bash "Strict Mode"
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
set -euo pipefail
# Define common constants regardless if they are used in the script
__my_name="$(basename "${BASH_SOURCE[0]}")"
readonly __my_name
__my_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly __my_dir
__my_path="${__my_dir}/${__my_name}"
# shellcheck disable=SC2034
readonly __my_path
__my_args="$*"
# shellcheck disable=SC2034
readonly __my_args
# Set IFS to just newline and tab
IFS=$'\n\t'
################################################################################
# <<< OBB:END

is_github_actions=false
if [[ "${GITHUB_ACTIONS:-}" == "true" ]]; then
  is_github_actions=true
fi

DRY_RUN="${DRY_RUN-}"
VERBOSE="${VERBOSE-}"

usage() {
  cat <<USAGE
Usage: ${__my_name} [--targets targets] [--exclude-paths exclude_paths] [--include-glob include_glob] [--organization-regexp organization_regexp] [--headers-regexp headers_regexp] [--dry-run] [--verbose] [--help|-h]

Options:
  --targets targets                       Directories to scan (default: .)
  --exclude-paths exclude_paths           Paths to exclude (default: .github/workflows)
  --include-glob include_glob             Optional include globs (default: empty)
  --organization-regexp organization_regexp
                                          Optional org/person regexp (used when --headers-regexp is empty)
  --headers-regexp headers_regexp         Sed regexps (one per line), use {{CURRENT_YEAR}}
  --dry-run                               Show what would change without modifying files
  --verbose                               Print detailed progress logs
  -h, --help                              Show this help message

For list options, pass a single option-argument and separate items with spaces, commas,
or newlines, for example:
  --targets ". src scripts"
  --exclude-paths ".github/workflows build"
  --include-glob "**/*.{sh,py,js}"

Environment:
  DRY_RUN=<any non-empty value>           Enable dry-run mode
  VERBOSE=<any non-empty value>           Enable verbose logs
USAGE
}

emit_group_start() {
  local title="$1"
  if [[ "${is_github_actions}" == true ]]; then
    echo "::group::${title}"
  elif [[ -n "${VERBOSE:-}" ]]; then
    echo "== ${title} =="
  fi
}

emit_group_end() {
  if [[ "${is_github_actions}" == true ]]; then
    echo "::endgroup::"
  fi
}

emit_warning() {
  local message="$1"
  if [[ "${is_github_actions}" == true ]]; then
    echo "::warning::${message}" >&2
  else
    echo "WARNING: ${message}" >&2
  fi
}

append_step_summary() {
  local line="$1"
  if [[ -n "${GITHUB_STEP_SUMMARY:-}" ]]; then
    printf '%s\n' "${line}" >> "${GITHUB_STEP_SUMMARY}" || true
  fi
}

log_info() {
  echo "$*"
}

log_verbose() {
  if [[ -n "${VERBOSE:-}" ]]; then
    echo "$*"
  fi
}

die() {
  if [[ "${is_github_actions}" == true ]]; then
    echo "::error::$*" >&2
  else
    echo "ERROR: $*" >&2
  fi
  exit 1
}

append_values() {
  local target_array_name="$1"
  local raw_values="$2"
  local normalized
  local token
  local -a tokens=()
  local -n target_array="${target_array_name}"

  normalized="${raw_values//,/ }"
  normalized="${normalized//$'\r'/ }"
  normalized="${normalized//$'\n'/ }"

  IFS=$' \n\t' read -r -a tokens <<< "${normalized}"
  for token in "${tokens[@]}"; do
    [[ -n "${token//[[:space:]]/}" ]] || continue
    target_array+=("${token}")
  done
}

# Defaults (env overrides with fallbacks)
TARGETS="${TARGETS:-.}"
EXCLUDE_PATHS="${EXCLUDE_PATHS:-.github/workflows}"
INCLUDE_GLOB="${INCLUDE_GLOB-}"
ORGANIZATION_REGEXP="${ORGANIZATION_REGEXP-}"
HEADERS_REGEXP="${HEADERS_REGEXP-}"
CURRENT_YEAR="${CURRENT_YEAR-}"

# CLI overrides
while (($#)); do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --targets)
      shift
      [[ $# -gt 0 ]] || die "Missing value for --targets"
      TARGETS="$1"
      ;;
    --exclude-paths)
      shift
      [[ $# -gt 0 ]] || die "Missing value for --exclude-paths"
      EXCLUDE_PATHS="$1"
      ;;
    --include-glob)
      shift
      [[ $# -gt 0 ]] || die "Missing value for --include-glob"
      INCLUDE_GLOB="$1"
      ;;
    --organization-regexp)
      shift
      [[ $# -gt 0 ]] || die "Missing value for --organization-regexp"
      ORGANIZATION_REGEXP="$1"
      ;;
    --headers-regexp)
      shift
      [[ $# -gt 0 ]] || die "Missing value for --headers-regexp"
      HEADERS_REGEXP="$1"
      ;;
    --dry-run)
      DRY_RUN=1
      ;;
    --verbose)
      VERBOSE=1
      ;;
    --)
      shift
      break
      ;;
    *)
      die "Unknown option: $1"
      ;;
  esac
  shift
done

if (($# > 0)); then
  die "Unexpected arguments: $*"
fi

if [[ -n "${ORGANIZATION_REGEXP}" ]]; then
  # Normalize double backslashes so callers can pass \ in YAML/shell.
  ORGANIZATION_REGEXP="${ORGANIZATION_REGEXP//\\\\/\\}"
fi

if [[ -n "${HEADERS_REGEXP}" ]]; then
  # Normalize double backslashes so callers can pass \\ in YAML/shell.
  HEADERS_REGEXP="${HEADERS_REGEXP//\\\\/\\}"
fi

if [[ -n "${CURRENT_YEAR}" ]]; then
  current_year="${CURRENT_YEAR}"
else
  current_year="$(date +%Y)"
fi

dry_run_enabled=false
verbose_enabled=false
if [[ -n "${DRY_RUN:-}" ]]; then
  dry_run_enabled=true
fi
if [[ -n "${VERBOSE:-}" ]]; then
  verbose_enabled=true
fi

log_info "Mode: dry-run=${dry_run_enabled}, verbose=${verbose_enabled}"

if [[ -z "${TARGETS//[[:space:]]/}" ]]; then
  emit_warning "No targets provided; nothing to do."
  append_step_summary "### ${__my_name}"
  append_step_summary "- Mode: dry-run=${dry_run_enabled}, verbose=${verbose_enabled}"
  append_step_summary "- Result: no targets provided"
  exit 0
fi

if [[ -z "${HEADERS_REGEXP//[[:space:]]/}" ]]; then
  if [[ -z "${ORGANIZATION_REGEXP//[[:space:]]/}" ]]; then
    HEADERS_REGEXP=$'s/^(.*Copyright[^0-9]*)([0-9]{4})(-[0-9]{4})?([[:space:]]+.*)?$/\\1\\2-{{CURRENT_YEAR}}\\4/'
  else
    default_with_org='s/^(.*Copyright[^0-9]*)([0-9]{4})(-[0-9]{4})?([[:space:]]+{{ORG}})?$/\1\2-{{CURRENT_YEAR}}\4/'
    HEADERS_REGEXP="${default_with_org//\{\{ORG\}\}/${ORGANIZATION_REGEXP}}"
  fi
fi

# Always collapse ranges like 2026-2026 back to 2026 after updates.
# This keeps single-year headers clean when the current year equals the start year.
if [[ -z "${ORGANIZATION_REGEXP//[[:space:]]/}" ]]; then
  cleanup_regex='s/^(.*Copyright[^0-9]*)([0-9]{4})-\2([[:space:]]+.*)?$/\1\2\3/'
else
  cleanup_with_org='s/^(.*Copyright[^0-9]*)([0-9]{4})-\2([[:space:]]+{{ORG}})?$/\1\2\3/'
  cleanup_regex="${cleanup_with_org//\{\{ORG\}\}/${ORGANIZATION_REGEXP}}"
fi

declare -a DIRS=()
declare -a EXCLUDES=()
declare -a INCLUDES=()
append_values DIRS "${TARGETS}"
append_values EXCLUDES "${EXCLUDE_PATHS}"
append_values INCLUDES "${INCLUDE_GLOB}"

mapfile -t REGEXPS <<< "${HEADERS_REGEXP}"

sed_args=()
for re in "${REGEXPS[@]}"; do
  [[ -n "${re}" ]] || continue
  re="${re//\{\{CURRENT_YEAR\}\}/${current_year}}"
  sed_args+=(-e "${re}")
done

if [[ "${#sed_args[@]}" -eq 0 ]]; then
  echo "headers_regexp must contain at least one non-empty regexp."
  exit 1
fi

shopt -s globstar
valid_dirs=0
candidate_files=0
updated_files=0
emit_group_start "Processing targets"
for dir in "${DIRS[@]}"; do
  [[ -d "${dir}" ]] || continue
  valid_dirs=$((valid_dirs + 1))

  prune_args=()
  for exclude in "${EXCLUDES[@]}"; do
    [[ -n "${exclude}" ]] || continue
    if [[ "${exclude}" == /* ]]; then
      prune_args+=(-path "${exclude}" -prune -o)
    else
      exclude="${exclude#./}"
      prune_args+=(-path "${dir%/}/${exclude}" -prune -o)
    fi
  done

  while IFS= read -r -d '' file; do
    if [[ "${#INCLUDES[@]}" -gt 0 ]]; then
      matched=false
      for pat in "${INCLUDES[@]}"; do
        [[ -n "${pat}" ]] || continue
        # shellcheck disable=SC2053
        if [[ "${file}" == ${pat} || "${file#./}" == ${pat} ]]; then
          matched=true
          break
        fi
      done
      [[ "${matched}" == true ]] || continue
    fi

    if [[ "$(file --mime-type --brief "${file}")" == text/* ]]; then
      candidate_files=$((candidate_files + 1))
      tmp_file="$(mktemp)"
      sed \
        --regexp-extended \
        "${sed_args[@]}" \
        -e "${cleanup_regex}" \
        "${file}" > "${tmp_file}"

      if ! cmp -s "${file}" "${tmp_file}"; then
        updated_files=$((updated_files + 1))
        if [[ "${dry_run_enabled}" == true ]]; then
          log_info "[DRY-RUN] Would update ${file}"
        else
          cat "${tmp_file}" > "${file}"
          log_verbose "Updated ${file}"
        fi
      else
        log_verbose "No change: ${file}"
      fi
      rm -f "${tmp_file}"
    fi
  done < <(find "${dir}" "${prune_args[@]}" -type f -print0)
done
emit_group_end

if [[ "${valid_dirs}" -eq 0 ]]; then
  emit_warning "No valid target directories found; nothing to do."
  append_step_summary "### ${__my_name}"
  append_step_summary "- Mode: dry-run=${dry_run_enabled}, verbose=${verbose_enabled}"
  append_step_summary "- Result: no valid target directories"
  exit 0
fi

append_step_summary "### ${__my_name}"
append_step_summary "- Mode: dry-run=${dry_run_enabled}, verbose=${verbose_enabled}"
append_step_summary "- Candidate files: ${candidate_files}"
append_step_summary "- Files to update: ${updated_files}"
append_step_summary "- Current year used: ${current_year}"

if [[ "${dry_run_enabled}" == true ]]; then
  log_info "Dry-run completed. Files to update: ${updated_files}"
else
  log_info "Completed. Updated files: ${updated_files}"
fi
