---
# SPDX-FileCopyrightText: 2025-2026  IMAGIN sp. z o.o.
# SPDX-FileContributor: Marcin Engelmann <mengelmann@octivi.com>
# SPDX-License-Identifier: MIT
#
# This file is part of the configuration created by Octivi's DevOps team.
# Details at https://octivi.com/devops

name: Update Copyright Year
description: Update copyright years in file headers based on provided sed regexps.
branding:
  icon: calendar
  color: blue
inputs:
  targets:
    description: "Directories to scan (space-separated), e.g. '. src scripts'"
    required: false
    default: "."
  exclude_paths:
    description: "Paths to exclude (space-separated), e.g. '.github/workflows build'"
    required: false
    default: ".github/workflows"
  include_glob:
    description: "Optional glob patterns to include (space-separated), e.g. '**/*.{sh,py,js}'"
    required: false
    default: ""
  organization_regexp:
    description: "Optional regexp snippet for the organization/person name after the year (used only when headers_regexp is empty)."
    required: false
    default: ""
  headers_regexp:
    description: "Array of sed regexps (one per line). Use {{CURRENT_YEAR}} as a placeholder."
    required: false
    default: |
      s/^(.*Copyright[^0-9]*)([0-9]{4})(-[0-9]{4})?([[:space:]]+.*)?$/\1\2-{{CURRENT_YEAR}}\4/
runs:
  using: composite
  steps:
    - name: Update year in headers
      shell: bash
      run: |
        set -o errexit -o nounset -o pipefail
        IFS=$'\n\t'

        current_year="$(date +%Y)"
        targets="${{ inputs.targets }}"
        exclude_paths="${{ inputs.exclude_paths }}"
        include_glob="${{ inputs.include_glob }}"
        organization_regexp="${{ inputs.organization_regexp }}"
        headers_regexp="${{ inputs.headers_regexp }}"

        if [[ -z "${targets//[[:space:]]/}" ]]; then
          echo "No targets provided; nothing to do."
          exit 0
        fi

        if [[ -z "${headers_regexp//[[:space:]]/}" ]]; then
          if [[ -z "${organization_regexp//[[:space:]]/}" ]]; then
            headers_regexp=$'s/^(.*Copyright[^0-9]*)([0-9]{4})(-[0-9]{4})?([[:space:]]+.*)?$/\\1\\2-{{CURRENT_YEAR}}\\4/'
          else
            default_with_org='s/^(.*Copyright[^0-9]*)([0-9]{4})(-[0-9]{4})?([[:space:]]+{{ORG}})?$/\1\2-{{CURRENT_YEAR}}\4/'
            headers_regexp="${default_with_org/{{ORG}}/${organization_regexp}}"
          fi
        fi

        # Always collapse ranges like 2026-2026 back to 2026 after updates.
        # This keeps single-year headers clean when the current year equals the start year.
        cleanup_regex='s/^(.*Copyright[^0-9]*)([0-9]{4})-\2([[:space:]]+.*)?$/\1\2\3/'

        IFS=$' \n\t' read -r -a DIRS <<< "${targets}"
        IFS=$' \n\t' read -r -a EXCLUDES <<< "${exclude_paths}"
        IFS=$' \n\t' read -r -a INCLUDES <<< "${include_glob}"

        mapfile -t REGEXPS <<< "${headers_regexp}"
        sed_args=()
        for re in "${REGEXPS[@]}"; do
          [[ -n "${re}" ]] || continue
          re="${re//\{\{CURRENT_YEAR\}\}/${current_year}}"
          sed_args+=(-e "${re}")
        done

        if [[ "${#sed_args[@]}" -eq 0 ]]; then
          echo "headers_regexp must contain at least one non-empty regexp."
          exit 1
        fi

        prune_args=()
        for exclude in "${EXCLUDES[@]}"; do
          prune_args+=(-path "./${exclude}" -prune -o)
        done

        shopt -s globstar
        valid_dirs=0
        for dir in "${DIRS[@]}"; do
          [[ -d "${dir}" ]] || continue
          valid_dirs=$((valid_dirs + 1))

          find "${dir}" "${prune_args[@]}" -type f -print0 | while IFS= read -r -d '' file; do
            if [[ "${#INCLUDES[@]}" -gt 0 ]]; then
              matched=false
              for pat in "${INCLUDES[@]}"; do
                [[ -n "${pat}" ]] || continue
                if [[ "${file}" == ${pat} || "${file#./}" == ${pat} ]]; then
                  matched=true
                  break
                fi
              done
              [[ "${matched}" == true ]] || continue
            fi

            if [[ "$(file --mime-type --brief "${file}")" == text/* ]]; then
              sed \
                --regexp-extended \
                --in-place \
                "${sed_args[@]}" \
                -e "${cleanup_regex}" \
                "${file}"
            fi
          done
        done

        if [[ "${valid_dirs}" -eq 0 ]]; then
          echo "No valid target directories found; nothing to do."
          exit 0
        fi
